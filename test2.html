<script>
  module = {};
</script>
<script src="https://unpkg.com/pixelmatch"></script>
<canvas id="cacanvas"></canvas>
<video id="videoElement" autoplay></video>

<script>
  const PROXIMITY_THRESHOLD = 100;
  const SCALE_FACTOR = 3;
  const MAX_RECTS = 10;

  const FPS = 10;
  const COMPARE_TRESHOLD = 0.2;
  const sources = ["/images/01.jpeg", "/images/02.jpeg"];
  const diffCanvas = document.getElementById("cacanvas");
  const diffContext = diffCanvas.getContext("2d");

  const helpers = {
    isClose: (pix1, pix2) => {
      return (
        Math.abs(pix1.x - pix2.x) < PROXIMITY_THRESHOLD &&
        Math.abs(pix1.y - pix2.y) < PROXIMITY_THRESHOLD
      );
    },
    compare: (img1, img2, width, height) => {
      diffCanvas.width = width;

      diffCanvas.height = height;
      const diff = diffContext.createImageData(width, height);
      pixelmatch(img1.data, img2.data, diff.data, width, height, {
        threshold: COMPARE_TRESHOLD,
      });
      return diff;
    },
    imageDataFromSource: async (source) => {
      const image = Object.assign(new Image(), { src: source });
      await new Promise((resolve) =>
        image.addEventListener("load", () => resolve())
      );

      const targetWidth = Math.floor(image.width / SCALE_FACTOR),
        targetHeight = Math.floor(image.height / SCALE_FACTOR);

      // Create two canvas elements: one for the downscaled image and one for the final image
      var tempCanvas = document.createElement("canvas");
      var tempCtx = tempCanvas.getContext("2d");
      var finalCanvas = document.createElement("canvas");
      var finalCtx = finalCanvas.getContext("2d");

      // Set the dimensions of the temporary canvas to the target dimensions
      tempCanvas.width = targetWidth;
      tempCanvas.height = targetHeight;
      <!-- tempCanvas.imageSmoothingEnabled = false; -->

      // Draw the image to the temporary canvas at the new smaller dimensions
      tempCtx.drawImage(image, 0, 0, targetWidth, targetHeight);

      // Set the dimensions of the final canvas to the original image dimensions
      finalCanvas.width = image.width;
      finalCanvas.height = image.height;
      <!-- finalCanvas.imageSmoothingEnabled = false; -->

      // Now draw the lower resolution image from the temporary canvas to the final canvas,
      // stretching it to the original image dimensions.
      finalCtx.drawImage(
        tempCanvas,
        0,
        0,
        targetWidth,
        targetHeight,
        0,
        0,
        image.width,
        image.height
      );
      return finalCtx.getImageData(0, 0, image.width, image.height);
    },
    applyConvolutionFilter: (
      src,
      kernel,
      divisor = 1,
      offset = 0,
      opaque = true
    ) => {
      var w = src.width;
      var h = src.height;

      var dst = new ImageData(w, h);

      var dstBuf = dst.data;
      var srcBuf = src.data;

      var rowOffset = Math.floor(kernel.length / 2);
      var colOffset = Math.floor(kernel[0].length / 2);

      for (var row = 0; row < h; row++) {
        for (var col = 0; col < w; col++) {
          var result = [0, 0, 0, 0];

          for (var kRow = 0; kRow < kernel.length; kRow++) {
            for (var kCol = 0; kCol < kernel[kRow].length; kCol++) {
              var kVal = kernel[kRow][kCol];

              var pixelRow = row + kRow - rowOffset;
              var pixelCol = col + kCol - colOffset;

              if (
                pixelRow < 0 ||
                pixelRow >= h ||
                pixelCol < 0 ||
                pixelCol >= w
              ) {
                continue;
              }

              var srcIndex = (pixelRow * w + pixelCol) * 4;

              for (var channel = 0; channel < 4; channel++) {
                if (opaque && channel === 3) {
                  continue;
                } else {
                  var pixel = srcBuf[srcIndex + channel];
                  result[channel] += pixel * kVal;
                }
              }
            }
          }

          var dstIndex = (row * w + col) * 4;

          for (var channel = 0; channel < 4; channel++) {
            var val =
              opaque && channel === 3
                ? 255
                : result[channel] / divisor + offset;
            dstBuf[dstIndex + channel] = val;
          }
        }
      }
      return dst;
    },
  };

  var video = document.querySelector("#videoElement");

  if (navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices
      .getUserMedia({ video: true })
      .then(function (stream) {
        video.srcObject = stream;
      })
      .catch(function (err0r) {
        console.log("Something went wrong!");
      });
  }
  video.addEventListener("loadedmetadata", function () {
    diffCanvas.width = video.videoWidth;
    diffCanvas.height = video.videoHeight;
  });
  video.addEventListener("play", async function (e) {
    diffContext.drawImage(e.srcElement, 0, 0);
    let last = diffContext.getImageData(
      0,
      0,
      diffCanvas.width,
      diffCanvas.height
    );
    while (true) {
      await new Promise((res) => setInterval(res, 1000 / FPS));
      diffContext.drawImage(e.srcElement, 0, 0);

      curr = diffContext.getImageData(
        0,
        0,
        diffCanvas.width,
        diffCanvas.height
      );
      const s = Date.now();
      await run([last, curr]);
      const frame = Date.now() - s;
      diffContext.font = "20px mono";
      diffContext.fillText(
        "FPS: " + parseInt(1000 / frame).toString(),
        diffCanvas.width - 100,
        diffCanvas.height - 20
      );
      last = curr;
    }
  });

  const run = async (r) => {
    <!-- const r = await Promise.all( -->
    <!--   sources.map((e) => { -->
    <!--     return helpers.imageDataFromSource(e); -->
    <!--   }) -->
    <!-- ); -->
    const { width, height } = r[0];

    // get diff as imageData
    const diff = helpers.compare(r[0], r[1], width, height);
    // draw
    diffContext.putImageData(diff, 0, 0);

    // get red pixels
    let redPixels = [];
    for (let i = 0; i < diff.data.length; i += 4) {
      let red = diff.data[i];
      let green = diff.data[i + 1];
      if (!(red > 200 && green < 50)) continue;
      let pixelPos = i / 4;
      let y = Math.floor(pixelPos / diff.width);
      let x = Math.floor(pixelPos % diff.width);
      redPixels.push({ x, y });
    }

    // define groups
    let groups = [[]];
    for (let i = 1; i < redPixels.length; i++) {
      <!-- if (!groups[groups.length - 1].length) -->
      if (helpers.isClose(redPixels[i], redPixels[i - 1])) {
        groups[groups.length - 1].push(redPixels[i]);
      } else {
        groups.push([redPixels[i]]);
      }
    }

    groups = groups.filter((e) => e.length > 100);

    // get min and max pixels for each group
    let boundingRects = groups
      .map((e) => {
        let xs = e.map((p) => p.x);
        let ys = e.map((p) => p.y);
        let xMax = Math.max(...xs);
        let yMax = Math.max(...ys);
        let xMin = Math.min(...xs);
        let yMin = Math.min(...ys);
        const size = Math.floor((xMax - xMin) * (yMax - yMin));
        return { xMax, yMax, xMin, yMin, size };
      })
      .sort((a, b) => a.size > b.size);

    if (boundingRects.length >= MAX_RECTS) boundingRects.splice(MAX_RECTS);
    // draw bounding rects

    diffContext.strokeStyle = "blue";
    boundingRects.forEach((box) => {
      diffContext.beginPath();
      diffContext.rect(
        box.xMin,
        box.yMin,
        Math.abs(box.xMax - box.xMin),
        Math.abs(box.yMax - box.yMin)
      );
      diffContext.stroke();
      diffContext.closePath();
    });

    const diffCanvas2 = document.getElementById("cacanvas2");
    const diffContext2 = diffCanvas.getContext("2d");

    return boundingRects;
  };

  window.onload = async () => {};
</script>
