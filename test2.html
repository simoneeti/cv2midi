<script>
  module = {};
</script>
<script src="https://unpkg.com/pixelmatch"></script>
<canvas id="cacanvas"></canvas>
<!-- <canvas id="cacanvas2" width=1600 height=900></canvas> -->

<script>
  const PROXIMITY_THRESHOLD = 100;

  async function imageDataFromSource(source) {
    const image = Object.assign(new Image(), { src: source });
    await new Promise((resolve) =>
      image.addEventListener("load", () => resolve()),
    );
    const context = Object.assign(document.createElement("canvas"), {
      width: image.width,
      height: image.height,
    }).getContext("2d");
    context.imageSmoothingEnabled = false;
    context.drawImage(image, 0, 0);
    return context.getImageData(0, 0, image.width, image.height);
  }

  const sources = ["/images/01.jpeg", "/images/02.jpeg"];
  const diffCanvas = document.getElementById("cacanvas");
  const diffContext = diffCanvas.getContext("2d");

  const compare = (img1, img2, width, height) => {
    diffCanvas.width = width;

    diffCanvas.height = height;
    const diff = diffContext.createImageData(width, height);
    pixelmatch(img1.data, img2.data, diff.data, width, height, {
      threshold: 0.3,
    });
    return diff;
  };

  const helpers = {
    isClose: (pix1, pix2) => {
      return (
        Math.abs(pix1.x - pix2.x) < PROXIMITY_THRESHOLD &&
        Math.abs(pix1.y - pix2.y) < PROXIMITY_THRESHOLD
      );
    },
  };

  const run = async () => {
    const r = await Promise.all(
      sources.map((e) => {
        return imageDataFromSource(e);
      }),
    );
    const { width, height } = r[0];

    // get diff as imageData
    const diff = compare(r[0], r[1], width, height);
    // draw
    diffContext.putImageData(diff, 0, 0);

    // get red pixels
    let redPixels = [];
    for (let i = 0; i < diff.data.length; i += 4) {
      let red = diff.data[i];
      let green = diff.data[i + 1];
      if (!(red > 200 && green < 50)) continue;
      let pixelPos = i / 4;
      let y = Math.floor(pixelPos / diff.width);
      let x = Math.floor(pixelPos % diff.width);
      redPixels.push({ x, y });
    }

    // define groups
    let groups = [[]];
    for (let i = 1; i < redPixels.length; i++) {
      <!-- if (!groups[groups.length - 1].length) -->
      if (helpers.isClose(redPixels[i], redPixels[i - 1])) {
        groups[groups.length - 1].push(redPixels[i]);
      } else {
        groups.push([redPixels[i]]);
      }
    }

    groups = groups.filter((e) => e.length > 100);

    // get min and max pixels for each group
    let boundingRects = groups.map((e) => {
      let xs = e.map((p) => p.x);
      let ys = e.map((p) => p.y);
      let xMax = Math.max(...xs);
      let yMax = Math.max(...ys);
      let xMin = Math.min(...xs);
      let yMin = Math.min(...ys);
      return { xMax, yMax, xMin, yMin };
    });

    // draw bounding rects
    console.log(boundingRects);

    diffContext.strokeStyle = "blue";
    boundingRects.forEach((box) => {
      diffContext.beginPath();
      diffContext.rect(
        box.xMin,
        box.yMin,
        Math.abs(box.xMax - box.xMin),
        Math.abs(box.yMax - box.yMin),
      );
      diffContext.stroke();
      diffContext.closePath();
    });

    return boundingRects;
  };

  window.onload = async () => {
    console.time("frame");
    await run();
    console.timeEnd("frame");
  };
</script>
